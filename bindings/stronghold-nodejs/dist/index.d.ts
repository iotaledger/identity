import { Storage, DID, KeyLocation, Signature, ChainState, IdentityState } from '@iota/identity-wasm/node';

declare class Stronghold implements Storage {
    private napiStronghold;
    constructor();
    init(snapshot: string, password: string, dropsave?: boolean): Promise<void>;
    static build(snapshot: string, password: string, dropsave?: boolean): Promise<Stronghold>;
    setPassword(encryptionKey: Uint8Array): Promise<void>;
    flushChanges(): Promise<void>;
    keyNew(did: DID, keyLocation: KeyLocation): Promise<string>;
    keyInsert(did: DID, keyLocation: KeyLocation, privateKey: string): Promise<string>;
    keyExists(did: DID, keyLocation: KeyLocation): Promise<boolean>;
    keyGet(did: DID, keyLocation: KeyLocation): Promise<string>;
    keyDel(did: DID, keyLocation: KeyLocation): Promise<void>;
    keySign(did: DID, keyLocation: KeyLocation, data: Uint8Array): Promise<Signature>;
    chainState(did: DID): Promise<ChainState>;
    setChainState(did: DID, chainState: ChainState): Promise<void>;
    state(did: DID): Promise<IdentityState>;
    setState(did: DID, identityState: IdentityState): Promise<void>;
    purge(did: DID): Promise<void>;
}

/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

declare class NapiChainState {
  static fromJSON(jsonValue: any): NapiChainState
  toJSON(): any
}
declare class NapiIdentityState {
  static fromJSON(jsonValue: any): NapiIdentityState
  toJSON(): any
}
declare class NapiStronghold {
  /**
   * Workaround for Napi not generating code when no factory or constructor is present, and
   * async constructors are not possible.
   */
  static f(): NapiStronghold
  /** Creates an instance of `Stronghold`. */
  static new(snapshot: string, password: string, dropsave?: boolean | undefined | null): Promise<NapiStronghold>
  /** Returns whether save-on-drop is enabled. */
  get dropsave(): boolean
  /**
   * Set whether to save the storage changes on drop.
   * Default: true
   */
  set dropsave(dropsave: boolean)
  /** Sets the account password. */
  setPassword(password: Array<number>): Promise<void>
  /** Write any unsaved changes to disk. */
  flushChanges(): Promise<void>
  /** Creates a new keypair at the specified `location` */
  keyNew(did: NapiDID, location: NapiKeyLocation): Promise<string>
  /** Inserts a private key at the specified `location`. */
  keyInsert(did: NapiDID, location: NapiKeyLocation, privateKey: string): Promise<string>
  /** Retrieves the public key at the specified `location`. */
  keyGet(did: NapiDID, location: NapiKeyLocation): Promise<string>
  /** Deletes the keypair specified by `location`. */
  keyDel(did: NapiDID, location: NapiKeyLocation): Promise<void>
  /** Signs `data` with the private key at the specified `location`. */
  keySign(did: NapiDID, location: NapiKeyLocation, data: Array<number>): Promise<NapiSignature>
  /** Returns `true` if a keypair exists at the specified `location`. */
  keyExists(did: NapiDID, location: NapiKeyLocation): Promise<boolean>
  /** Returns the chain state of the identity specified by `did`. */
  chainState(did: NapiDID): Promise<NapiChainState | undefined | null>
  /** Set the chain state of the identity specified by `did`. */
  setChainState(did: NapiDID, chainState: NapiChainState): Promise<void>
  /** Returns the state of the identity specified by `did`. */
  state(did: NapiDID): Promise<NapiIdentityState | undefined | null>
  /** Sets a new state for the identity specified by `did`. */
  setState(did: NapiDID, state: NapiIdentityState): Promise<void>
  /** Removes the keys and any state for the identity specified by `did`. */
  purge(did: NapiDID): Promise<void>
}
declare class NapiKeyLocation {
  static fromJSON(jsonValue: any): NapiKeyLocation
  toJSON(): any
}
declare class NapiSignature {
  static fromJSON(jsonValue: any): NapiSignature
  toJSON(): any
}
declare class NapiDID {
  static fromJSON(jsonValue: any): NapiDID
}

export { NapiChainState, NapiDID, NapiIdentityState, NapiKeyLocation, NapiSignature, NapiStronghold, Stronghold };
