use crate::{
  identity_core::{Object, Timestamp},
  proof::ProofOptions,
};

#[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
pub struct LinkedDataProof {
  /// The digital signature suite that was used to create the signature.
  #[serde(rename = "type")]
  pub type_: String,
  /// Parameters required to independently verify the proof.
  #[serde(rename = "verificationMethod")]
  pub verification_method: String,
  /// The specific intent for the proof.
  #[serde(rename = "proofPurpose")]
  pub proof_purpose: String,
  /// TODO
  #[serde(rename = "proofValue")]
  pub proof_value: String,
  /// A timestamp generated by the proof algorithm.
  pub created: Timestamp,
  /// The restricted domain of the proof.
  #[serde(skip_serializing_if = "Option::is_none")]
  pub domain: Option<String>,
  /// A value used once for a particular domain and window of time; used to
  /// mitigate replay attacks.
  #[serde(skip_serializing_if = "Option::is_none")]
  pub nonce: Option<String>,
  /// Miscellaneous properties
  #[serde(flatten)]
  pub properties: Object,
}

impl LinkedDataProof {
  pub fn to_options(&self) -> ProofOptions {
    ProofOptions {
      verification_method: self.verification_method.to_owned(),
      created: Some(self.created.to_owned()),
      proof_purpose: Some(self.proof_purpose.to_owned()),
      domain: self.domain.to_owned(),
      nonce: self.nonce.to_owned(),
    }
  }
}
