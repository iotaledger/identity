use identity_common::Timestamp;

use crate::signature::SignatureOptions;

/// A representation of a linked data signature
///
/// Ref: https://w3c-ccg.github.io/ld-proofs/#linked-data-signatures
#[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
pub struct LinkedDataSignature {
    /// The digital signature suite that was used to create the signature.
    #[serde(rename = "type")]
    pub proof_type: String,
    /// The value of the encoded digital signature.
    #[serde(rename = "proofValue")]
    pub proof_value: String,
    /// The specific intent for the proof.
    #[serde(rename = "proofPurpose")]
    pub purpose: String,
    /// A timestamp generated by the proof algorithm.
    pub created: Timestamp,
    /// The restricted domain of the proof.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    /// A value used once for a particular domain and window of time; used to
    /// mitigate replay attacks.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,
}

impl LinkedDataSignature {
    /// Copies from the signature to return a new `SignatureOptions` struct.
    pub fn to_options(&self) -> SignatureOptions {
        SignatureOptions {
            created: Some(self.created),
            purpose: Some(self.purpose.clone()),
            domain: self.domain.clone(),
            nonce: self.nonce.clone(),
        }
    }
}
