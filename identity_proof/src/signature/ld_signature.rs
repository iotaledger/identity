use identity_core::common::Timestamp;
use serde::{Deserialize, Serialize};

use crate::signature::{SignatureData, SignatureOptions, SignatureValue};

/// A representation of a linked data signature
///
/// Ref: https://w3c-ccg.github.io/ld-proofs/#linked-data-signatures
#[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
pub struct LdSignature {
    /// The digital signature suite that was used to create the signature.
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "verificationMethod")]
    pub verification_method: String,
    /// The specific intent for the proof.
    #[serde(rename = "proofPurpose", skip_serializing_if = "Option::is_none")]
    pub proof_purpose: Option<String>,
    /// A timestamp generated by the proof algorithm.
    pub created: Timestamp,
    /// The restricted domain of the proof.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    /// A value used once for a particular domain and window of time; used to
    /// mitigate replay attacks.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,
    /// The value and misc. properties of the linked data signature.
    #[serde(flatten)]
    pub data: SignatureData,
}

impl LdSignature {
    pub fn new(type_: impl Into<String>, options: SignatureOptions) -> Self {
        Self {
            type_: type_.into(),
            verification_method: options.verification_method,
            proof_purpose: options.proof_purpose,
            created: options.created.unwrap_or_else(Timestamp::now),
            domain: options.domain,
            nonce: options.nonce,
            data: SignatureData {
                value: SignatureValue::Signature(String::new()),
                properties: options.properties,
            },
        }
    }

    /// Returns the raw (str) value of the signature proof.
    pub fn proof(&self) -> &str {
        self.data.value.value()
    }
}
