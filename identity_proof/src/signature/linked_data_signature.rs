use identity_common::Timestamp;
use serde::{Deserialize, Serialize};

use crate::signature::{SignatureData, SignatureOptions};

/// A representation of a linked data signature
///
/// Ref: https://w3c-ccg.github.io/ld-proofs/#linked-data-signatures
#[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
pub struct LinkedDataSignature {
    /// The digital signature suite that was used to create the signature.
    #[serde(rename = "type")]
    pub proof_type: String,
    /// The specific intent for the proof.
    #[serde(rename = "proofPurpose")]
    pub purpose: String,
    /// A timestamp generated by the proof algorithm.
    pub created: Timestamp,
    /// The restricted domain of the proof.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    /// A value used once for a particular domain and window of time; used to
    /// mitigate replay attacks.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,
    /// The value and misc. properties of the linked data signature.
    #[serde(flatten)]
    pub data: SignatureData,
}

impl LinkedDataSignature {
    /// Returns the raw (str) value of the signature proof.
    pub fn proof(&self) -> &str {
        self.data.value.value()
    }

    /// Copies from the signature to return a new `SignatureOptions` struct.
    pub fn to_options(&self) -> SignatureOptions {
        SignatureOptions {
            created: Some(self.created),
            purpose: Some(self.purpose.clone()),
            domain: self.domain.clone(),
            nonce: self.nonce.clone(),
            properties: self.data.clone().into(),
        }
    }
}
